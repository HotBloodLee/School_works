日志记录1:（2020.3.23）（Q_001）
	Q_001：和AS上面的过程类似，第一步希望实现关键字高亮显示。
		一开始一直把小程序当做html去写了，后来反应过来

	后来找到了一个类似于html的js里面的innerhtml方法，即点击按钮动态添加组件，这样的话把查询结果一条一条显示，只需要
	把每一句切开成几个部分，各个部分分别用不同颜色来显示，这样就避免换行之后各部分必须在同一列
	（主要是还没有了解到如何让一部分文字颜色改变）
	附上源码（学习了csdn大佬）：



	下述代码功能未完全实现，还在改
		wxml：（部分）
			<view wx:for="{{info.details}}" wx:key="key" class="forItemBorder">
			 <view>
			    <text space="ensp">{{res1}}</text>
			    <text class='t' space="ensp">{{res2}}</text>
			    <text space="ensp">{{res3}}</text>
			  </view>
			</view>
	
		wx:for="{{items}}",意思是遍历items这个数组，也就是你从后台获取的数据，然后存进setData({ items: items })中
		wx:key="{{index}}"这个方法可写可不写，对小程序没影响，只是它一般和wx:for连着一起用的
		wx:for-index="index"这个方法的意思是可指定数组当前下标的变量名，个人觉得它就是用来显示数组索引的。比如在
			上述代码示例中，有条目{{index+1}}，解析数据之后，显示依次为条目1，条目2，条目3....
		wx:for-item="自己随便取名"这个方法比较实用些，意思是可指定数组当前元素的变量名。怎么理解呢？它的作用就是把
			遍历数组得到的每一条数据存储在一个变量名上（意思就是上述items的别名），就比如上述代码示例中，wx:for-item="items"，
			就是把要遍历的items数据赋值给items了，所以下面调用数据的时候用items.xxx；如果你把wx:for-item="wx"，那么下面调用数据的时候，应该是wx.content、wx.answer等
		
		js：主要是创建了一个类，每点击一下就添加一个类到屏幕上
			function Detail(placeName, number) {
			  this.placeName = placeName;
			  this.number = number;
			}
			function Info() {
			  this.details = [];
			}

			Page({
			  data: {
			    info: {},
			    
			    shi3: "诗三百全文",
			    keystr: "花",
			    res: "",
			    res1: "",
			    res2: "",
			    res3: "",
			  },

			go2s函数：(修改之后主要是负责保存查询结果，不显示，不判断，里面的i是全局，方便后期一条一条的显示)
			go2s: function (e) {
			    this.data.i = 0
			    this.data.keystr = e.detail.value.keystr
			    this.data.res = ""
			    // 第一次读入“唐诗300首”等
			    if (this.data.shi3.length < 20) {
			      var that = this
			      wx.request({
				url: 'http://202.194.7.180:8022/qqq/shi300.txt',
				success(res) {
				  //console.log(res.data)
				  that.data.shi3 = res.data
				  console.log("ok")
				  lines = that.data.shi3.split("\n")
				}
			      })
			    }
			  },

			看不懂的几个函数：（类似于创建并显示）
			init: function () {
			    let that = this;
			    this.setData({
			      info: new Info(),
			    });
			},
			onLoad: function (options) {
			    this.init();
			},
			setPlace: function (e) {
			    let index = parseInt(e.currentTarget.id.replace("place-", ""));
			    let place = e.detail.value;
			    let info = this.data.info;
			    info.details[index].placeName = place;
			    this.setData({
			      info: info
			    });
			},
			setNumber: function (e) {
			    let index = parseInt(e.currentTarget.id.replace("number-", ""));
			    let number = e.detail.value;
			    let info = this.data.info;
			    info.details[index].number = number;
			    this.setData({
			      info: info
			    });
			},

			添加、删除函数：
			addItem: function (e) {
			    if (this.data.shi3 != '诗三百全文'){
			      let info = this.data.info;
			      info.details.push(new Detail());
			      var reg = new RegExp(".*" + this.data.keystr + ".*")
			      while (!reg.test(lines[this.data.i])) {
				this.data.i += 1
			      }

			      line = lines[this.data.i].split(this.data.keystr)
			      if (line[0] == "") {
				this.data.res1 = ""
				this.data.res2 = this.data.keystr
				this.data.res3 = line[1]
			      } else if (line[1] == "") {
				this.data.res1 = line[0]
				this.data.res2 = this.data.keystr
				this.data.res3 = ""
			      } else {
				this.data.res1 = line[0]
				this.data.res2 = this.data.keystr
				this.data.res3 = line[1]
			      }
			      console.log(line[0])
			      console.log(line[1])
			      console.log(line[2])
			      this.data.i += 1

			      this.setData({
				info: info,
				res1: this.data.res1,
				res2: this.data.res2,
				res3: this.data.res3,
			      });
			    }else{

			    }
			  },
			removeItem: function (e) {
			   //还在思考怎么实现
			},

	了解了this.setData，还有wxml的module（好像叫这个），还有spilt（）拆分很方便

	通过
	<view>
		<text space="ensp">试试</text>
		<text class='t' space="ensp">花</text>
		<text space="ensp">试试</text>
	</view>
	来保证花可以高亮显示

	最难受的地方，那个循环语句，有时候编译会死循环，有时候又正常
	找到了死循环原因，
	success(res) {
          //console.log(res.data)
          that.data.shi3 = res.data
          console.log("ok")
          lines = this.data.shi3.split("\n")
          console.log(lines[70])
        }
	lines的赋值一定要在success里面，不然有可能lines先赋值，但是数据没有传回来

	Q_001未解决

日志记录2：（2020.3.25）（Q_001）
	初步改了一下上次的结果，可以实现一行更换，但是没有办法使用添加按钮实现既显示上一条的结果，又显示下一条，每次一点就上下行都是同一句诗，之前的句子就被替换了，
	希望可以有一个办法可以把结果保留住，不用随着{{}}里面的值变化而变化

	然后我想到了可不可以就在微信里面显示html，这样就直接用html写
	有一个web-view的标签，但是是全屏进入网页
	还有一个wxparse解析，试试看

	wxparse成功

	Q_001未解决

日志记录3：（2020.3.29）（Q_001）
	根据上次操作wxparse成功，优化了各功能，取消了原来的info（动态添加组件），用html就很方便操作各字段样式
	也学习了一下 wx.getFileSystemManager().copyFile 和 wx.getFileSystemManager().readFile 读存本地数据
	主要是连不上shi300.txt，只能先用本地数据，顺便多学一些

	先贴代码，注释见：（只是关于wxparse，和文件读取的内容）

	wxml：
		  <import src="../../wxParse/wxParse.wxml"/>
		  <template is="wxParse" data="{{wxParseData:article.nodes}}"/>
		  //这两行引入wxparse包以及在template处显示html内容，js里面设置内容

	wxss：
		@import "/wxParse/wxParse.wxss";
		//引入包

	js：
		var WxParse = require('../../wxParse/wxParse.js')
		this.data.info_text = ""
		WxParse.wxParse('article', 'html', this.data.info_text, this, 0)
		//先引入，后设置html标签并加载到页面

		wx.getFileSystemManager().copyFile({  //先把文件复制到可操作的文件夹
			srcPath: 'src/txt/shi300.txt', //源文件
			destPath: wx.env.USER_DATA_PATH + '/shi300.txt',	//可操作的文件夹路径
			success: res => {
				console.log("ok")		//复制成功返回res信息
			},
			fail: console.error		//复制失败返回error
		})

		wx.getFileSystemManager().readFile({  //读取文件
			filePath: wx.env.USER_DATA_PATH + '/shi300.txt',
			encoding: 'utf-8',
			success: res => {
				console.log("ok")
				that.data.shi3 = res.data
				lines = that.data.shi3.split("\n")
			},
			fail: console.error
		})

	每点一次“下一条”按钮，就会加载下一条诗句，并且关键字高亮，以前的诗句也都在
		line = lines[this.data.i].split(this.data.keystr)
		if (line[0] == "") {
			this.data.res1 = ""
			this.data.res2 = this.data.keystr
			this.data.res3 = line[1]
		} else if (line[1] == "") {
			this.data.res1 = line[0]
			this.data.res2 = this.data.keystr
			this.data.res3 = ""
		} else {
			this.data.res1 = line[0]
			this.data.res2 = this.data.keystr
			this.data.res3 = line[1]
		}
		console.log(line[0])
		console.log(line[1])
		console.log(line[2])
		this.data.info_text += "<a>" + this.data.res1 + "<font style='color: orange'>" + this.data.res2 + "</font>" + this.data.res3 + "</a>"
		WxParse.wxParse('article', 'html', this.data.info_text, this, 0)
		this.data.i += 1

		用了三个if，感觉有点呆，应该是包含了所有情况

	如果检索完了，要显示没有多的了
		if(this.data.i == lines.length){
		  this.data.info_text += "<a><font style='color: red'>没有更多的结果了</font></a>"
		  WxParse.wxParse('article', 'html', this.data.info_text, this, 0)
		  return
		}
	
	点删除，就是页面全部清除，赋值就行了

	Q_001解决
